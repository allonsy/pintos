       	       	     +-------------------------+
		     |		CS 140	       |
		     | PROJECT 4: FILE SYSTEMS |
		     |	   DESIGN DOCUMENT     |
		     +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.



Alejandro Younger <acy1@uchicago.edu>
Alec Snyder <alsnyder@uchicago.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

I definitely did not start this project early enough, considering my earlier
deadline. As a result, there is a lot of functionality lacking, and 
some design decisions have yet to be made.

I also wrote some code for the new inode.c framework (ie, for extensibility, etc)
but was unable to get it to play nice with the cache framework in a reasonable time frame.
If you look at my repository, this is the newinode.c file.


>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

		     INDEXED AND EXTENSIBLE FILES
		     ============================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* NOTE: THESE ARE FROM THE FRAMEWORK THAT DID NOT WORK OUT */

struct inode 
  {
    struct list_elem elem;              /* Element in inode list. */
    block_sector_t sector;              /* Sector number of disk location. */
    int open_cnt;                       /* Number of openers. */
    bool removed;                       /* True if deleted, false otherwise. */
    struct lock lock;                   /* Protects the inode. */

    /* Denying writes. */
    struct lock deny_write_lock;        /* Protects members below. */
    struct condition no_writers_cond;   /* Signaled when no writers. */ 
    int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
    int writer_cnt;                     /* Number of writers. */
  };

>> A2: What is the maximum size of a file supported by your inode
>> structure?  Show your work.

/* Again this is from the framework that didn't make it into my final commit */
Roughly 8MB. The doubly indirect block dominates the computation, and has
128 pointers to blocks with 128 pointers which each hold 512 bytes.
This is ultimately 2^23 bytes, or 8MB.


---- SYNCHRONIZATION ----

>> A3: Explain how your code avoids a race if two processes attempt to
>> extend a file at the same time.

Only one thread can write to a given block at a time (via the cache_lock setup)
thus only one thread can add a new block at a time, since adding this new block
requires editing the inode block (ie, writing to it).

>> A4: Suppose processes A and B both have file F open, both
>> positioned at end-of-file.  If A reads and B writes F at the same
>> time, A may read all, part, or none of what B writes.  However, A
>> may not read data other than what B writes, e.g. if B writes
>> nonzero data, A is not allowed to see all zeros.  Explain how your
>> code avoids this race.

Readers can only access a given block if there are no writers, hence if
A tries to read a block being written, A will not see it OR will see the data B wrote.

>> A5: Explain how your synchronization design provides "fairness".
>> File access is "fair" if readers cannot indefinitely block writers
>> or vice versa.  That is, many processes reading from a file cannot
>> prevent forever another process from writing the file, and many
>> processes writing to a file cannot prevent another process forever
>> from reading the file.

I do not actually handle this case. 

---- RATIONALE ----

>> A6: Is your inode structure a multilevel index?  If so, why did you
>> choose this particular combination of direct, indirect, and doubly
>> indirect blocks?  If not, why did you choose an alternative inode
>> structure, and what advantages and disadvantages does your
>> structure have, compared to a multilevel index?

Yes. It was suggested. It is complicated. It is ugly. 

			    SUBDIRECTORIES
			    ==============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Did not get to this while struggling VS caching.

---- ALGORITHMS ----

>> B2: Describe your code for traversing a user-specified path.  How
>> do traversals of absolute and relative paths differ?

See B1.

---- SYNCHRONIZATION ----

>> B4: How do you prevent races on directory entries?  For example,
>> only one of two simultaneous attempts to remove a single file
>> should succeed, as should only one of two simultaneous attempts to
>> create a file with the same name, and so on.

Directories are files, and removal (or creation) requires editing the block 
either holding the file in question or where the next available entry is. 
Only one thread can edit a block at a time, so this prevents the race. 

>> B5: Does your implementation allow a directory to be removed if it
>> is open by a process or if it is in use as a process's current
>> working directory?  If so, what happens to that process's future
>> file system operations?  If not, how do you prevent it?

See B1.

---- RATIONALE ----

>> B6: Explain why you chose to represent the current directory of a
>> process the way you did.

See B1.

			     BUFFER CACHE
			     ============

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Type of block lock. */
enum lock_type 
  {
    NON_EXCLUSIVE,	/* Any number of lockers. */
    EXCLUSIVE		/* Only one locker. */
  };

  /* this comment added for commit reasons */


 struct cache_block 
  {
    struct lock block_lock;
    struct condition no_readers_or_writers; /* for signalling a waiting writer */
    struct condition no_writers;            /* for signalling readers waiting on writers */     
    int readers, read_waiters;				/* protected by block_lock, the number of readers or waiters */
    int writers, write_waiters;				/* protected by block_lock, the number of writers or waiters */
    block_sector_t sector;					/* the block sector currently in this cache segment */
    bool up_to_date;						/* is this segment up to date with the disk? */
    bool dirty;								/* has this segment been written to? */
    bool is_free;							/* for cache eviction policies */
    struct lock data_lock; 					/* protects data */
    uint8_t data[BLOCK_SECTOR_SIZE];   		/* actual data */
  };

---- ALGORITHMS ----

>> C2: Describe how your cache replacement algorithm chooses a cache
>> block to evict.

I went with random eviction, as this was fast to implement.

>> C3: Describe your implementation of write-behind.

We store things in cache and when there are no readers or writers or waiting threads
we write back. 

>> C4: Describe your implementation of read-ahead.

Did not do so.

---- SYNCHRONIZATION ----

>> C5: When one process is actively reading or writing data in a
>> buffer cache block, how are other processes prevented from evicting
>> that block?

We check that there are no readers or writers before we evict the block.
If there are, we generate another random cache block to evict.

>> C6: During the eviction of a block from the cache, how are other
>> processes prevented from attempting to access the block?

eviction and accessing are both handled in cache_lock, which is protected
by the cache_sync lock, hence only one thread can do so at a time.

---- RATIONALE ----

>> C7: Describe a file workload likely to benefit from buffer caching,
>> and workloads likely to benefit from read-ahead and write-behind.

Any workload that repeatedly accesses the same file, like a data base or something,
would be good for buffer caching.

Any work (changes) that get done with frequency on the same small blocks would benefit
from write_behind since this reduces the IOs if there are many changes being made.

Read ahead helps workloads like watching movies or listening to music, where
sequential access of blocks is practically guaranteed.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

This assignment was hard, but mostly I didn't start in time.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

It was cool to see the parallels between VM and buffer cache, and how 
cool solutions can be applied to several problems.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

Some of the guides were not clear, in particular on how the members
of the cache_block were supposed to interact. 

>> Do you have any suggestions for the TAs to more effectively assist
>> students in future quarters?

>> Any other comments?

Really enjoyed this class, despite the multitude of hours in the lab. 
To me, that is the signof a good course. 